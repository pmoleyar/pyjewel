    def process_blocks(self):
        """Check the board for adjacent matching jewels"""
        print('process_blocks')
        # Check consecutive matching blocks horizontally
        self.print_board()
        print('Finding matching horizontal blocks')

        # TODO See if we can use itertools.groupby
        # https://stackoverflow.com/questions/44790869/
        # find-indexes-of-repeated-elements-in-an-array-python-numpy
        # /44792205#44792205

        for r in range(NROWS):
            # For this row, create ordered list of (value, cell)
            L = [(self.board[r][c], (r, c)) for c in range(NCOLS)]
            # Identify consecutive groups of same value (value != 0)
            groups = [list(g) for k, g in groupby(L, lambda x: x[0]) if k]
            # Pick only groups of length >= 3
            len3reps = [g for g in groups if len(g) >= 3]
            # Extract a flat list of indices from the list of lists
            indices = [x[1] for len3rep in len3reps for x in len3rep]
            print(indices)
            self.verify_match_pieces(indices)
            match_jewels = [self.fallen_jewels.find(i[1], i[0]) \
                    for i in indices]
            self.flashing_jewels.extend(match_jewels)

        while False:
        #for r in range(NROWS):
            match_count = 1
            last_piece = 0
            # Remember there's an extra column for this convenience
            for c in range(NCOLS+1):
                if self.board[r][c] == last_piece and (last_piece != 0):
                    match_count += 1
                else:
                    last_piece = self.board[r][c]
                    if match_count <= 2:
                        match_count = 1
                        continue

                    # match_count > 2 here
                    # TODO Increment score
                    #add_score POINTS, match_count

                    # TODO Mark for deletion [r][c] match_count
                    indices = self.jewel_line_indices('h', r, c-1, match_count)
                    print(indices)
                    self.verify_match_pieces(indices)
                    match_jewels = [self.fallen_jewels.find(i[1], i[0]) \
                            for i in indices]
                    self.flashing_jewels.extend(match_jewels)
                    # Seek match afresh
                    match_count = 1
        

        # Check consecutive matching blocks vertically
        print('Finding matching vertical blocks')
        for c in range(NCOLS):
            match_count = 1
            last_piece = 0
            # Remember there's an extra row for this convenience
            for r in range(NROWS+1):
                if self.board[r][c] == last_piece and (last_piece != 0):
                    match_count += 1
                else:
                    last_piece = self.board[r][c]
                    if match_count <= 2:
                        match_count = 1
                        continue
                    # match_count > 2 here
                    #add_score POINTS, match_count

                    # Mark for deletion
                    indices = self.jewel_line_indices('v', r-1, c, match_count)
                    print(indices)
                    self.verify_match_pieces(indices)
                    match_jewels = [self.fallen_jewels.find(i[1], i[0]) \
                            for i in indices]
                    self.flashing_jewels.extend(match_jewels)
                    # Seek match afresh
                    match_count = 1

        # Check consecutive matching blocks diagonally left
        # TODO

        # Check consecutive matching blocks diagonally right
        # TODO

        # Schedule deletion
        # (with a further mutual recursive call into this function)
        # only if there's something to delete
        if len(self.flashing_jewels):
            arcade.schedule(self.delete_jewels, FLASH_DELAY)
        else:
            # No more processing needed
            self.processing_block = False

